<#
.SYNOPSIS
	Creates a command batch from a CSV file as the data source for the command parameters.
.DESCRIPTION
	This script can be used to convert command batches from CSV to XML. 
	The input data file can contain the name of the command to carry out for each CSV record in
	the column named CommandName, but this is not neccessary. The script parameter -defaultCommandName
	can be used if the data source only contains data and no command names.
	
	Each column, except for CommandName, is mapped to command parameters. However, the parameter can
	be overridden in the file by specifying the target parameter name in square brackets - for example:
	
	Titel [Title],Benämning [Description],Annat []
	
	Note: Using an empty set of brackets ignores the column.
	
	If the source file can't be modified for column to parameter name mapping there are some 
	script parameters available to accomplish the same thing;
	-columnToParameterMap is specificed as a hash table and -ignoredColumns is a string array. 
	The column to parameter name mapping example above can be accomplished using the following:
	-columnToParameterMap @{ "Titel" = "Title"; "Benämning" = "Description" } 
	-ignoredColumns "Annat"

	Multiple target parameters is supported by separating the target parameter names with comma:

	ProduktNr [UnitId|Code]
	
	- or, the command line argument -
	
	-columnToParameterMap @{ "ProduktNr" = "UnitId|Code" } 
	
	If the file comes from Excel it may be saved using ASCII or UTF7 encoding. To convert the 
	data source from that encoding to UTF8 the following parameter can be used:
	-reencodeFromEncoding UTF7
	
	To preview the specified column to parameter name mapping without actually creating 
	an XML file, use the -preview switch.
.PARAMETER csvFile
	The path of the CSV file
.PARAMETER outputFile
	The path to the XML file to be created
.PARAMETER defaultCommandName
	The command name to be used for each CSV record if not specified in the CommandName column
.PARAMETER filter
	A row filter to apply to the source file before processing any rows
.PARAMETER columnToParameterMap
	A hashtable defining mappings of source column to destination parameter(s)
.PARAMETER ignoredColumns
	A list of colums to skip when mapping CSV columns to command parameters
.PARAMETER columnValuePrefix
	A hashtable defining mappings of column to parameter value prefixes to be applied to the source data.
	Pro tip: Can be used to add prefixes like "System.Picklist.Unit.Types." to data that needs to be a localization keyword.
.PARAMETER reencodeFromEncoding
	If present, source encoding for the source file. Pro tip: Specify UTF7 if source file is generated by Excel. 
.PARAMETER preview
	Only prints the CSV column to command parameter mapping and does not produce the output file.
.PARAMETER continueOnError
	When a command fails, default mode is to reject all commands sent to the API.
	This option changes this and will persist all changes made by commands that executed successfully.
#>
param( 
	[parameter(mandatory=$true, valuefrompipeline=$true)]
	$csvFile,
	[parameter(mandatory=$true)]
	$outputFile,
	[parameter(mandatory=$false)]
	$defaultCommandName = "",
	[parameter(mandatory=$false)]
	[scriptblock] $filter = $null,
	[parameter(mandatory=$false)]
	[hashtable]$columnToParameterMap = @{},
	[parameter(mandatory=$false)]
	[string[]]$ignoredColumns = @(),
	[parameter(mandatory=$false)]
	[hashtable]$columnValuePrefix = @{},
	[parameter(mandatory=$false)]
	[Microsoft.PowerShell.Commands.FileSystemCmdletProviderEncoding] $Encoding = [Microsoft.PowerShell.Commands.FileSystemCmdletProviderEncoding]::UTF8,
	[parameter(mandatory=$false)]
	[Switch] $preview = $false,
	[parameter(mandatory=$false)]
	[int] $chunkSize = 200,
	[parameter(mandatory=$false)]
	$batchId = "CommandBatch",
	$delimiter = ",",
	[parameter(mandatory=$false,helpmessage="Persist all successful commands even if some are failing")]
	[Switch] $continueOnError
)

$lines = gc $csvFile -Encoding $Encoding
$header = $lines[0].TrimEnd($delimiter).Split($delimiter)
$data = $lines | select -Skip 1 | ?{ $_.Trim($delimiter) } | ConvertFrom-Csv -Header $header -Delimiter $delimiter
$recordCount = $lines.Length-1
Write-Host "Found $recordCount records"

if(!$columnToParameterMap) { $columnToParameterMap = @{} }
if(!$ignoredColumns) { $ignoredColumns = @() }
if(!$columnValuePrefix) { $columnValuePrefix = @{} }

$xmlns = "http://schemas.remotex.net/Apps/201207/Commands"
$attrs = $header | ?{ $_ -notmatch "\[?CommandName\]?" -and $_ -notmatch "\[?Target\]?" } 
$commandNameColumn = $header | ?{ $_ -match "\[?CommandName\]?" }
$targetColumn = $header | ?{ $_ -match "[\[\|]?Target[\]\|]?" }

function getParameterNameForColumn( $columnName ) {
	$columnName = $columnName.Trim()
	if( $ignoredColumns -contains $columnName ) {
		""
	} elseif( $columnToParameterMap.ContainsKey( $columnName ) ) {
		$columnToParameterMap[$columnName]
	} elseif( $columnName -match "(?<=\[)[^\]]*(?=\])" ) {
		$matches[0]
	} else {
		$columnName
	}
}
function getParameterValueForColumn( $columnName, $value ) {
	$columnName = $columnName.Trim()
	$value.Split("|") | %{ 
		$v = $_
		if( $columnValuePrefix.ContainsKey( $columnName ) ) {
			[string]::Concat( $columnValuePrefix[$columnName], $v ).Trim()
		} else {

			$lookupTable = @{
				'<' = '&lt;' 
				'>' = '&gt;' 
				'`r' = ' ' 
				'`n' = ' ' 
				'`t' = ' ' 
				'"' = '&quot;'
				'''' = '&apos;'
			}

			$line = $v.Trim() -replace '&', '&amp;'
			$lookupTable.GetEnumerator() | %{
				if ($line -match $_.Key)
				{
					$line = $line -replace $_.Key, $_.Value
				}
			}
			$line
		}
	}
}

$parameterMap = $attrs | select @{Name="Column";Expression={ $_ }},@{Name="Parameter";Expression={ getParameterNameForColumn $_ }}
Write-Host "Parameter map:"
$parameterMap | ?{ $_.Parameter } | %{
	Write-Host ("  {0} => {1}" -f $_.Column, $_.Parameter)
}
Write-Host "Ignored columns:"
( $ignoredColumns + ( $attrs | ?{ $_ -match "\[\]" } ) ) | select -Unique | %{
	$ignoredColumn = $_.Trim()
	Write-Host "  $ignoredColumn"
}
Write-Host ""

if($preview) {
	return
}

if( ![System.IO.Path]::IsPathRooted( $outputFile ) ) {
	$outputFile = Join-Path $PWD $outputFile
}

if( !$filter ) {
	$filteredRecords = $data
	$filteredRecordCount = $recordCount
} else {
	Write-Progress -Activity "Filtering records" -Status "Filtering..." -PercentComplete 0
	$ri = 0
	$filteredRecords = $data | ?{ 
		Write-Progress -Activity "Filtering records" -Status "Filtering..." -PercentComplete (100 * ( $ri++ / $recordCount ) )	
		[scriptblock]::Create($filter.ToString().Replace( "$_", "$args[0]") ).InvokeReturnAsIs($_) 
	}
	$filteredRecordCount = ($filteredRecords | measure).Count
	Write-Progress -Activity "Filtering records" -Status "Filtering..." -PercentComplete 100 -Completed
}
if( $filteredRecordCount -ne $recordCount ) {
	Write-Host "Filtered out $filteredRecordCount records matching $($filter.ToString())"
}
if(!$filteredRecordCount) {
	return
}

function tellProgress( $status, $percentComplete, $SecondsRemaining = -1 ) {
	Write-Progress -Activity "Chunking records into command batches..." -Status "Chunk: $chunkNumber" -CurrentOperation $status -PercentComplete $percentComplete -Completed:$($percentComplete -eq 100) -SecondsRemaining $SecondsRemaining
}

function Chunk( $size ) {
	begin { 
		$chunk = @()
		$count = 0 
	} 
	process { 
		$chunk += $_
		if( ++$count -eq $size ) { 
			@(, $chunk )
			$chunk = @()
			$count = 0 
		} 
	}
	end { 
		if( $chunk ) { 
			@(, $chunk ) 
		}
	}
}

function AsCommand {
	begin {
		$recordNumber = 0
	}
	process {
		$record = $_
		$recordNumber++
		if( $commandNameColumn -and $record."$commandNameColumn" ) {
	    	$CommandName = $record."$commandNameColumn"
		} elseif( $defaultCommandName ) {
			$CommandName = $defaultCommandName
		} else {
			throw "Error: Can't figure command for record $record"
		}
	    $Command = "<Command>`r`n<Name>$CommandName</Name>`r`n"
		if( $targetColumn -and $record."$targetColumn" ) {
	    	$Command += "<Target>{0}</Target>`r`n" -f $record."$targetColumn"
		}
	    
	    foreach ($attr in $attrs){
	        $val = $record."$attr"
	        if($val){
				(getParameterNameForColumn ($attr.ToString())).Split("|") | ?{ ![string]::IsNullOrEmpty( $_ ) } | %{
					$valueElements = getParameterValueForColumn $_ $val | %{ 
						# Trim qoutes - empty parameter values can be entered to csv by using '' or "" 
						$parameterValue = $_.Trim(@( '''', '"' ))
						"<Value>{0}</Value>" -f $parameterValue 
					} | Out-String
		            $Command += "<Parameter><Name>{0}</Name>{1}</Parameter>`r`n" -f $_, $valueElements
				}
	        }
	    }
		"$Command</Command>"
	}
}

function SaveAsBatch {
	begin {
		$chunkNumber = 0
		$sw = [System.Diagnostics.Stopwatch]::StartNew()
		$coeElement = ""
		if( $continueOnError ) {
			$coeElement = "<ContinueOnError>true</ContinueOnError>"
		}
	}
	process {
		$chunk = $_
		$chunkNumber++
		$currentBatchId = "{0} - chunk {1}" -f $batchId.Trim(), $chunkNumber
		tellProgress "Creating batch #$chunkNumber" (100 * ( $chunkNumber / $chunks )) (($chunks-$chunkNumber) * ($sw.Elapsed.TotalSeconds / $chunkNumber))
		$fileName = $outputFile -replace "\.xml$","_Chunk-$chunkNumber.xml"
		@"
<?xml version="1.0" encoding="utf-8"?>
<CommandBatch xmlns="$xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<Id>$currentBatchId</Id>
$coeElement
"@ | Set-Content -Encoding UTF8 -Path $fileName
		$chunk | Add-Content -Encoding UTF8 -Path $fileName
		[byte[]][char[]]"</CommandBatch>" | Add-Content -Encoding byte -Path $fileName
		Resolve-Path $fileName
	}
}
$chunks = [int]([Math]::Ceiling( $filteredRecordCount / $chunkSize ))
tellProgress "Processing records..." 0
$filteredRecords | AsCommand | Chunk -size $chunkSize | SaveAsBatch
tellProgress "All chunks done!" 100 0